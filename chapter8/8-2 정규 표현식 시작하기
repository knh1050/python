[ ] 문자 - 문자 클래스

문자 클래스를 만드는 메타 문자인 [ ] 사이에는 어떤 문자도 들어갈 수 있다.

즉, 정규 표현식이 [abc]라면 이 표현식의 의미는 ‘a, b, c 중 한 개의 문자와 매치’를 뜻한다.

"a"는 정규식과 일치하는 문자인 "a"가 있으므로 매치된다.
"before"는 정규식과 일치하는 문자인 "b"가 있으므로 매치된다.
"dude"는 정규식과 일치하는 문자인 a, b, c 중 어느 하나도 포함하고 있지 않으므로 매치되지 않는다.
[] 안의 두 문자 사이에 하이픈(-)을 사용하면 두 문자 사이의 범위를 의미한다. 예를 들어 [a-c]라는 정규 표현식은 [abc]와 동일하고 [0-5]는 [012345]와 동일하다.

[a-zA-Z] : 모든 알파벳
[0-9] : 모든 숫자
문자 클래스([]) 안에는 어떤 문자나 메타 문자도 사용할 수 있지만, 주의해야 할 메타 문자가 1가지 있다. 그것은 바로 ^인데, 문자 클래스 안에 ^ 메타 문자를 사용할 경우에는 반대(not)라는 의미를 갖는다. 예를 들어 [^0-9]라는 정규 표현식은 숫자가 아닌 문자만 매치된다.

[0-9] 또는 [a-zA-Z] 등은 무척 자주 사용하는 정규 표현식이다. 이렇게 자주 사용하는 정규식은 별도의 표기법으로 표현할 수 있다.

\d - 숫자와 매치된다. [0-9]와 동일한 표현식이다.
\D - 숫자가 아닌 것과 매치된다. [^0-9]와 동일한 표현식이다.
\s - 화이트스페이스(whitespace) 문자와 매치된다. [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈칸은 공백 문자(space)를 의미한다.
\S - 화이트스페이스 문자가 아닌 것과 매치된다. [^ \t\n\r\f\v]와 동일한 표현식이다.
\w - 문자+숫자(alphanumeric)와 매치된다. [a-zA-Z0-9_]와 동일한 표현식이다.
\W - 문자+숫자(alphanumeric)가 아닌 문자와 매치된다. [^a-zA-Z0-9_]와 동일한 표현식이다.

-----------------------------------------------------------------------------------------------

.(dot) 문자 - \n을 제외한 모든 문자
정규 표현식의 .(dot) 메타 문자는 줄바꿈 문자인 \n을 제외한 모든 문자와 매치된다는 것을 의미한다.

정규식을 작성할 때 re.DOTALL 옵션을 주면 .(dot) 문자와 \n 문자도 매치된다.

a.b
"a + 모든_문자 + b"
즉, a와 b라는 문자 사이에 어떤 문자가 들어가도 모두 매치된다는 의미이다.

이해를 돕기 위해 문자열 "aab", "a0b", "abc"가 정규식 a.b와 어떻게 매치되는지 살펴보자.

"aab"는 가운데 문자 "a"가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치된다.
"a0b"는 가운데 문자 "0"가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치된다.
"abc"는 "a"문자와 "b"문자 사이에 어떤 문자라도 하나는 있어야 하는 이 정규식과 일치하지 않으므로 매치되지 않는다.

a[.]b
이렇게 [] 안에 . 문자를 쓰면 여기서 .는 메타 문자가 아니라 ‘.’ 문자 그대로를 의미한다.
"a + . + b"
따라서 정규식 a[.]b는 "a.b" 문자열과 매치되고 "a0b" 문자열과는 매치되지 않는다.

-----------------------------------------------------------------------------------------------

* 문자

ca*t
이 정규식은 반복을 의미하는 * 메타 문자를 사용했다. 여기에서 사용한 *은 * 바로 앞에 있는 문자 a가 0부터 무한대까지 반복될 수 있다는 의미이다.

* 메타 문자의 반복 개수가 무한대라고 표현했는데, 메모리 용량에 한계가 있어 실제로는 약 2억 개라고 한다.

ca*t	ct	Yes	"a"가 0번 반복되어 매치
ca*t	cat	Yes	"a"가 0번 이상 반복되어 매치 (1번 반복)
ca*t	caaat	Yes	"a"가 0번 이상 반복되어 매치 (3번 반복)


-----------------------------------------------------------------------------------------------

+ 문자
반복을 나타내는 또 다른 메타 문자로 +가 있다. +는 최소 1번 이상 반복될 때 사용한다. 즉, *가 반복 횟수가 0부터라면 +는 반복 횟수가 1부터인 것이다.


ca+t
"c + a가_1번_이상_반복 + t"

ca+t	ct	No	"a"가 0번 반복되어 매치되지 않음
ca+t	cat	Yes	"a"가 1번 이상 반복되어 매치 (1번 반복)
ca+t	caaat	Yes	"a"가 1번 이상 반복되어 매치 (3번 반복)

-----------------------------------------------------------------------------------------------

{} 문자와 ? 문자
여기에서 잠깐 생각해 볼 것이 있다. 반복 횟수를 3회만 또는 1회부터 3회까지만으로 제한하고 싶을 수도 있지 않을까? 이럴 때 {} 메타 문자를 사용하면 반복 횟수를 고정할 수 있다. {m, n} 정규식을 사용하면 반복 횟수가 m부터 n까지인 문자와 매치할 수 있다. m 또는 n을 생략할 수도 있다. 만약 {3,}처럼 사용하면 반복 횟수가 3 이상인 경우이고 {, 3}처럼 사용하면 반복 횟수가 3 이하인 경우를 의미한다. 생략된 m은 0과 동일하며, 생략된 n은 무한대(약 2억 개 미만)의 의미를 갖는다.

{1,}은 +, {0,}은 *와 동일하다.

{}을 사용한 몇 가지 정규식 예시를 살펴보자.

1. {m}
ca{2}t

"c + a를_반드시_2번_반복 + t"

ca{2}t	cat	No	"a"가 1번만 반복되어 매치되지 않음.
ca{2}t	caat	Yes	"a"가 2번 반복되어 매치

2. {m, n}
ca{2,5}t

"c + a를_2~5회_반복 + t"

ca{2,5}t	cat	No	"a"가 1번만 반복되어 매치되지 않음.
ca{2,5}t	caat	Yes	"a"가 2번 반복되어 매치
ca{2,5}t	caaaaat	Yes	"a"가 5번 반복되어 매치

3. ?
반복은 아니지만 이와 비슷한 기능을 하는 ? 문자가 있다. ? 메타 문자가 의미하는 것은 {0, 1}이다.


ab?c
"a + b가_있어도_되고_없어도_됨 + c"

ab?c	abc	Yes	"b"가 1번 사용되어 매치
ab?c	ac	Yes	"b"가 0번 사용되어 매치
즉, b 문자가 있거나 없거나 둘 다 매치되는 경우이다.

*, +, ? 메타 문자는 모두 {m, n} 형태로 고쳐 쓰는 것이 가능하지만, 이해하기 쉽고 표현도 간결한 *, +, ? 메타 문자를 사용하는 것이 좋다.

-----------------------------------------------------------------------------------------------

파이썬에서 정규 표현식을 지원하는 re 모듈
파이썬은 정규 표현식을 지원하기 위해 re(regular expression) 모듈을 제공한다. re 모듈은 파이썬을 설치할 때 자동으로 설치되는 표준 라이브러리로, 사용 방법은 다음과 같다.

>>> import re
>>> p = re.compile('ab*')
re.compile을 사용하여 정규 표현식(위 예에서는 ab*)을 컴파일한다. re.compile의 리턴값을 객체 p(컴파일된 패턴 객체)에 할당해 그 이후의 작업을 수행할 것이다.

-----------------------------------------------------------------------------------------------

정규식을 이용한 문자열 검색

match()	문자열의 처음부터 정규식과 매치되는지 조사한다.
search()	문자열 전체를 검색하여 정규식과 매치되는지 조사한다.
findall()	정규식과 매치되는 모든 문자열(substring)을 리스트로 리턴한다.
finditer()	정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 리턴한다.
match, search는 정규식과 매치될 때는 match 객체를 리턴하고 매치되지 않을 때는 None을 리턴한다. match 객체란 정규식의 검색 결과로 리턴된 객체를 말한다.


>>> import re
>>> p = re.compile('[a-z]+')

-----------------------------------------------------------------------------------------------

match
match 메서드는 문자열의 처음부터 정규식과 매치되는지 조사한다.

>>> m = p.match("python")
>>> print(m)
<re.Match object; span=(0, 6), match='python'>
"python" 문자열은 [a-z]+ 정규식에 부합되므로 match 객체가 리턴된다.

>>> m = p.match("3 python")
>>> print(m)
None
"3 python" 문자열은 처음에 나오는 문자 3이 정규식 [a-z]+에 부합되지 않으므로 None이 리턴된다.

match의 결과로 match 객체 또는 None을 리턴하기 때문에 파이썬 정규식 프로그램은 보통 다음과 같은 흐름으로 작성한다.

p = re.compile(정규표현식)
m = p.match( '조사할 문자열' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')
즉, match의 결괏값이 있을 때만 그다음 작업을 수행하겠다는 것이다.

-----------------------------------------------------------------------------------------------

search

>>> m = p.search("python")
>>> print(m)
<re.Match object; span=(0, 6), match='python'>
"python" 문자열에 search 메서드를 수행하면 match 메서드를 수행했을 때와 동일하게 매치된다.

>>> m = p.search("3 python")
>>> print(m)
<re.Match object; span=(2, 8), match='python'>
"3 python" 문자열의 첫 번째 문자는 "3"이지만, search는 문자열의 처음부터 검색하는 것이 아니라 문자열 전체를 검색하기 때문에 "3" 이후의 "python" 문자열과 매치된다.

이렇듯 match 메서드와 search 메서드는 문자열의 처음부터 검색할지의 여부에 따라 다르게 사용해야 한다.

-----------------------------------------------------------------------------------------------

findall

>>> result = p.findall("life is too short")
>>> print(result)
['life', 'is', 'too', 'short']
findall은 패턴([a-z]+)과 매치되는 모든 값을 찾아 리스트로 리턴한다.

-----------------------------------------------------------------------------------------------

finditer

>>> result = p.finditer("life is too short")
>>> print(result)
<callable_iterator object at 0x01F5E390>
>>> for r in result: print(r)
...
<re.Match object; span=(0, 4), match='life'>
<re.Match object; span=(5, 7), match='is'>
<re.Match object; span=(8, 11), match='too'>
<re.Match object; span=(12, 17), match='short'>
finditer는 findall과 동일하지만, 그 결과로 반복 가능한 객체(iterator object)를 리턴한다. 그리고 반복 가능한 객체가 포함하는 각각의 요소는 match 객체이다.

-----------------------------------------------------------------------------------------------

match 객체의 메서드
match 객체란 앞에서 살펴본 p.match, p.search 또는 p.finditer 메서드에 의해 리턴된 매치 객체(Match Object)를 의미한다.

group	매치된 문자열을 리턴한다.
start	매치된 문자열의 시작 위치를 리턴한다.
end	매치된 문자열의 끝 위치를 리턴한다.
span	매치된 문자열의 (시작, 끝)에 해당하는 튜플을 리턴한다.

>>> m = p.match("python")
>>> m.group()
'python'
>>> m.start()
0
>>> m.end()
6
>>> m.span()
(0, 6)
예상한 대로 결괏값이 출력되는 것을 확인할 수 있다. match 메서드를 수행한 결과로 리턴된 match 객체로 start 메서드를 사용했을 때 결괏값은 항상 0일 수밖에 없다. match 메서드는 항상 문자열의 시작부터 조사하기 때문이다.
만약 search 메서드를 사용했다면 m.start() 값은 다음과 같이 다르게 나올 것이다.

>>> m = p.search("3 python")
>>> m.group()
'python'
>>> m.start()
2
>>> m.end()
8
>>> m.span()
(2, 8)

-----------------------------------------------------------------------------------------------

